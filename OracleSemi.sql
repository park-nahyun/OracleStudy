SELECT USER
FROM DUAL;
--==>> SCOTT


SELECT USER
FROM DUAL;
--==>> SCOTT

DROP TABLE DROP_OUT;
DROP TABLE GRADE;
DROP TABLE SUBJECT_OPENED;
DROP TABLE ENROLMENT;
DROP TABLE COURSE_OPENED;
DROP TABLE TEXTBOOK;
DROP TABLE SUBJECT;
DROP TABLE COURSE;
DROP TABLE CLASSROOM;
DROP TABLE POINTS;
DROP TABLE STUDENT;
DROP TABLE PROFESSOR;
DROP TABLE ADMIN;


-- 테이블 생성 
--------------------------------------------------------------------------------
--1. ADMIN 
CREATE TABLE ADMIN
( ADMIN_NUM VARCHAR2(10)
, ADMIN_ID  VARCHAR2(10)
, ADMIN_PW  VARCHAR2(16)    CONSTRAINT ADM_ADMINPW_NN NOT NULL
, CONSTRAINT ADM_ADMINNUM_PK PRIMARY KEY(ADMIN_NUM)
, CONSTRAINT ADM_ADMINID_UK UNIQUE(ADMIN_ID)
, CONSTRAINT ADM_ADMINPW_CK CHECK(LENGTH(ADMIN_PW)>=4 AND LENGTH(ADMIN_PW)<=16)
);
--==>> Table ADMIN이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--2. PROFESSOR
-- ■■교수(유림작성)
CREATE TABLE PROFESSOR
(PROF_NUM   VARCHAR2(10)
,PROF_NAME  NVARCHAR2(10) CONSTRAINT PRO_PROFNAME_NN NOT NULL
,PROF_PW    VARCHAR2(16)  --Nullable
,PROF_SSN   VARCHAR2(14) CONSTRAINT PRO_PROSSN_NN NOT NULL
,PROF_REGI  DATE DEFAULT SYSDATE
,CONSTRAINT PRO_PROFNUM_PK PRIMARY KEY(PROF_NUM)
,CONSTRAINT PRO_PROFSSN_UK UNIQUE(PROF_SSN)
,CONSTRAINT PRO_PROFSSN_CK CHECK(SUBSTR(PROF_SSN,8,1) IN ('1','2','3','4') AND LENGTH(PROF_SSN)=14)
,CONSTRAINT PRO_PROFPW_CK CHECK(LENGTH(PROF_PW)>=4)
);
--==>>Table PROFESSOR이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--3. STUDENT
-- 학생 테이블
-- 학생 테이블 구성 ( 학생번호, 학생이름, 패스워드, 주민등록번호, 등록일자 )
CREATE TABLE STUDENT
( STUD_NUM   VARCHAR2(10)   CONSTRAINT STU_STUDNUM_NN  NOT NULL
, STUD_NAME  NVARCHAR2(30)  CONSTRAINT STU_STUDNAME_NN NOT NULL
, STUD_PW    VARCHAR2(16)
, STUD_SSN   VARCHAR2(14)   CONSTRAINT STU_STUDSSN_NN  NOT NULL
, STUD_REGI  DATE           DEFAULT SYSDATE

, CONSTRAINT STU_STUDNUM_PK  PRIMARY KEY(STUD_NUM)
, CONSTRAINT STU_STUDSSN_UK  UNIQUE (STUD_SSN)
, CONSTRAINT STU_STUDSSN_CK  CHECK(LENGTH(STUD_SSN) >= 14 AND LENGTH(STUD_SSN) <=14)
, CONSTRAINT STU_STUDPW_CK   CHECK(LENGTH(STUD_PW) >= 4)
);
--==>> Table STUDENT이(가) 생성되었습니다.

--------------------------------------------------------------------------------
--4. POINTS
CREATE TABLE POINTS
( PNT_NUM      VARCHAR2(10)                                                                                                                                                 
, PNT_WRT      NUMBER(3)    CONSTRAINT PNT_PNTWRT_NN NOT NULL
, PNT_PRAC     NUMBER(3)    CONSTRAINT PNT_PNTPRAC_NN NOT NULL
, PNT_ATTD     NUMBER(3)    CONSTRAINT PNT_PNTATTD_NN NOT NULL
, CONSTRAINT PNT_PNTNUM_PK  PRIMARY KEY(PNT_NUM)
);
--==>> Table POINTS이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--5. CLASSROOM
CREATE TABLE CLASSROOM
( ROOM_NUM  VARCHAR2(10)
, ROOM_NAME NVARCHAR2(20)   CONSTRAINT CLA_ROOMNAME_NN NOT NULL
, CONSTRAINT CLA_ROOMNUM_PK PRIMARY KEY(ROOM_NUM)
, CONSTRAINT CLA_ROOMNAME_UK UNIQUE(ROOM_NAME)
);
--==>> Table CLASSROOM이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--6. COURSE
CREATE TABLE COURSE
(
  COUR_NUM  VARCHAR2(10)
, COUR_NAME NVARCHAR2(30)    CONSTRAINT COU_COURNAME_NN NOT NULL
, CONSTRAINT COU_COURNUM_PK PRIMARY KEY(COUR_NUM) 
, CONSTRAINT COU_COURNAME_UK UNIQUE(COUR_NAME)
);
--==>> Table COURSE이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--7. SUBJECT
-- ■■과목(유림작성)
CREATE TABLE SUBJECT
(SUBJ_NUM   VARCHAR2(10)
,SUBJ_NAME  NVARCHAR2(20) CONSTRAINT SUB_SUBJNAME_NN NOT NULL
,CONSTRAINT SUB_SUBJNUM_PK PRIMARY KEY(SUBJ_NUM)
,CONSTRAINT SUB_SUBJNAME_UK UNIQUE(SUBJ_NAME) 
);
--==>> Table SUBJECT이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--8. TEXTBOOK
-- 교재 테이블
-- 교재 테이블 구성 ( 교재번호, 교재명, 출판사, 저자 )
CREATE TABLE TEXTBOOK
( BOOK_NUM    VARCHAR2(10)  CONSTRAINT TXT_BOOKNUM_NN    NOT NULL
, BOOK_NAME   NVARCHAR2(20) CONSTRAINT TXT_BOOKNAME_NN   NOT NULL
, BOOK_PUBL   NVARCHAR2(10) CONSTRAINT TXT_BOOKPUBL_NN   NOT NULL
, BOOK_AUTH NVARCHAR2(10)   CONSTRAINT TXT_BOOKWRITER_NN NOT NULL

, CONSTRAINT TXT_BOOKNUM_PK  PRIMARY KEY(BOOK_NUM)
);
--==>> Table TEXTBOOK이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--9. COURSE_OPENED
CREATE TABLE COURSE_OPENED
( CO_NUM        VARCHAR2(10)
, COUR_NUM      VARCHAR2(10)    CONSTRAINT CO_COURNUM_NN NOT NULL
, CO_START      DATE            CONSTRAINT CO_COSTART_NN NOT NULL
, CO_FINISH     DATE            CONSTRAINT CO_COFINISH_NN NOT NULL
, ROOM_NUM      VARCHAR2(10)    CONSTRAINT CO_ROOMNUM_NN NOT NULL
, CO_DATE       DATE            DEFAULT SYSDATE
, CONSTRAINT CO_CONUM_PK  PRIMARY KEY(CO_NUM)
, CONSTRAINT CO_COURNUM_FK FOREIGN KEY(COUR_NUM)
              REFERENCES COURSE(COUR_NUM)
, CONSTRAINT CO_ROOMNUM_FK FOREIGN KEY(ROOM_NUM)
              REFERENCES CLASSROOM(ROOM_NUM)
);
--==>> Table COURSE_OPENED이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--10. ENROLMENT
CREATE TABLE ENROLMENT
( ROL_NUM    VARCHAR2(10)
, CO_NUM     VARCHAR2(10)   CONSTRAINT ENR_CONUM_NN NOT NULL
, STUD_NUM   VARCHAR2(10)   CONSTRAINT ENR_STUDNUM_NN NOT NULL
, ROL_DATE   DATE           DEFAULT SYSDATE
, CONSTRAINT ENR_ROLNUM_PK PRIMARY KEY(ROL_NUM)
, CONSTRAINT ENR_CONUM_FK FOREIGN KEY(CO_NUM) 
             REFERENCES COURSE_OPENED(CO_NUM)
, CONSTRAINT ENR_STUDNUM_FK FOREIGN KEY(STUD_NUM) 
             REFERENCES STUDENT(STUD_NUM)
);
--==>> Table EBRIKNEBT이(가) 생성되었습니다.
DROP TABLE ENROLMENT;

--------------------------------------------------------------------------------
--11. SUBJECT_OPENED
CREATE TABLE SUBJECT_OPENED
(
  SO_NUM    VARCHAR2(10)     
, SO_DATE   DATE             DEFAULT SYSDATE 
, SUBJ_NUM  VARCHAR2(10)     CONSTRAINT SO_SUBJNUM_NN NOT NULL
, CO_NUM    VARCHAR2(10)     CONSTRAINT SO_CONUM_NN NOT NULL
, PROF_NUM  VARCHAR2(10)     CONSTRAINT SO_PROFNUM_NN NOT NULL
, SO_START  DATE             CONSTRAINT SO_SOSTART_NN NOT NULL
, SO_FINISH DATE             CONSTRAINT SO_SOFINISH_NN NOT NULL
, PNT_NUM   VARCHAR2(10)     
, BOOK_NUM  VARCHAR2(10)     CONSTRAINT SO_BOOKNUM_NN NOT NULL
, SO_EXAM   NVARCHAR2(50)
, EXAM_DATE DATE             CONSTRAINT SO_EXAMDATE_NN NOT NULL
, CONSTRAINT SO_SONUM_PK PRIMARY KEY(SO_NUM)
, CONSTRAINT SO_SUBJNUM_FK FOREIGN KEY(SUBJ_NUM)
                           REFERENCES SUBJECT(SUBJ_NUM)
, CONSTRAINT SO_CONUM_FK FOREIGN KEY(CO_NUM)
                         REFERENCES COURSE_OPENED(CO_NUM)
, CONSTRAINT SO_PROFNUM_FK FOREIGN KEY(PROF_NUM)   
                           REFERENCES PROFESSOR(PROF_NUM)
, CONSTRAINT SO_PNTNUM_FK FOREIGN KEY(PNT_NUM)
                          REFERENCES POINTS(PNT_NUM)
, CONSTRAINT SO_BOOKNUM_FK FOREIGN KEY(BOOK_NUM)
                           REFERENCES TEXTBOOK(BOOK_NUM)
);
--==>> Table SUBJECT_OPENED이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--12. GRADE
-- ■■성적(유림작성)
CREATE TABLE GRADE
(GR_NUM      VARCHAR2(10)
,GR_WRT      NUMBER(3) --Nullable
,GR_PRAC     NUMBER(3) --Nullable
,GR_ATTD     NUMBER(3) --Nullable
,ROL_NUM     VARCHAR2(10) CONSTRAINT GRA_ROLNUM_NN NOT NULL
,SO_NUM      VARCHAR2(10) CONSTRAINT GRA_SONUM_NN NOT NULL
,CONSTRAINT GRA_GRNUM_PK PRIMARY KEY(GR_NUM)
,CONSTRAINT GRA_ROLNUM_FK FOREIGN KEY(ROL_NUM) REFERENCES ENROLMENT(ROL_NUM)
,CONSTRAINT GRA_SONUM_FK FOREIGN KEY(SO_NUM) REFERENCES SUBJECT_OPENED(SO_NUM)
);
--==>> Table GRADE이(가) 생성되었습니다.


--------------------------------------------------------------------------------
--13. DROP_OUT
-- 중도탈락 테이블
-- 중도탈락 테이블 구성 ( 중도탈락번호, 수강신청번호, 중도탈락일자, 중도탈락 사유 )
CREATE TABLE DROP_OUT
( DO_NUM     VARCHAR2(10)  
, ROL_NUM    VARCHAR2(10)        CONSTRAINT DRO_ROLNUM_NN NOT NULL
, DO_DATE    DATE                CONSTRAINT DRO_DODATE_NN NOT NULL
, DO_WHY     NVARCHAR2(20)       CONSTRAINT DRO_DOWHY_NN  NOT NULL

, CONSTRAINT DRO_DONUM_PK   PRIMARY KEY(DO_NUM)
, CONSTRAINT DRO_ROLNUM_FK  FOREIGN KEY(ROL_NUM)
  REFERENCES ENROLMENT(ROL_NUM)
); 
--==>> Table DROP_OUT이(가) 생성되었습니다.



-- 샘플 데이터 입력
--ADMIN
INSERT INTO ADMIN(ADMIN_ID, ADMIN_PW)
VALUES('AAAA', '1234');
--==>> 1 행 이(가) 삽입되었습니다.
SELECT *
FROM ADMIN;
--==>> AAAA	1234


--COURSE
INSERT INTO COURSE(COUR_NUM, COUR_NAME)
VALUES('C0001', '개발자');
INSERT INTO COURSE(COUR_NUM, COUR_NAME)
VALUES('C0002', 'DBA');
INSERT INTO COURSE(COUR_NUM, COUR_NAME)
VALUES('C0003', '기획자');
INSERT INTO COURSE(COUR_NUM, COUR_NAME)
VALUES('C0004', '보안');
INSERT INTO COURSE(COUR_NUM, COUR_NAME)
VALUES('C0005', '서버관리');
--==>> 1 행 이(가) 삽입되었습니다. * 5
SELECT *
FROM COURSE;
--==>>
/*
C0001	개발자
C0002	DBA
C0003	기획자
C0004	보안
C0005	서버관리
*/


ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';

--SUBJECT_OPENED
INSERT INTO SUBJECT_OPENED(SO_NUM, SO_DATE, SUBJ_NUM, CO_NUM, PROF_NUM, SO_START, SO_FINISH, PNT_NUM, BOOK_NUM, SO_EXAM, EXAM_DATE)
VALUES('SO0001', '2021-03-23', 'S0001', 'C0001', 'PF0001', '2021-04-01', '2021-07-28', 'P0001', 'B0001', '중간고사', '2021-05-24');
INSERT INTO SUBJECT_OPENED(SO_NUM, SO_DATE, SUBJ_NUM, CO_NUM, PROF_NUM, SO_START, SO_FINISH, PNT_NUM, BOOK_NUM, SO_EXAM, EXAM_DATE)
VALUES('SO0002', '2021-04-01', 'S0002', 'C0002', 'PF0002', '2021-04-05', '2021-08-10', 'P0002', 'B0002', '중간고사', '2021-06-24')
INSERT INTO SUBJECT_OPENED(SO_NUM, SO_DATE, SUBJ_NUM, CO_NUM, PROF_NUM, SO_START, SO_FINISH, PNT_NUM, BOOK_NUM, SO_EXAM, EXAM_DATE)
VALUES('SO0003', '2021-04-23', 'S0003', 'C0003', 'PF0003', '2021-04-30', '2021-08-15', 'P0003', 'B0003', '중간고사', '2021-06-30');
INSERT INTO SUBJECT_OPENED(SO_NUM, SO_DATE, SUBJ_NUM, CO_NUM, PROF_NUM, SO_START, SO_FINISH, PNT_NUM, BOOK_NUM, SO_EXAM, EXAM_DATE)
VALUES('SO0004', '2021-05-01', 'S0004', 'C0004', 'PF0004', '2021-05-05', '2021-08-28', 'P0004', 'B0004', '중간고사', '2021-07-14');
INSERT INTO SUBJECT_OPENED(SO_NUM, SO_DATE, SUBJ_NUM, CO_NUM, PROF_NUM, SO_START, SO_FINISH, PNT_NUM, BOOK_NUM, SO_EXAM, EXAM_DATE)
VALUES('SO0005', '2021-05-13', 'S0005', 'C0005', 'PF0005', '2021-05-19', '2021-09-01', 'P0005', 'B0005', '중간고사', '2021-08-02');


/*
DROP TABLE DROP_OUT;
DROP TABLE GRADE;
DROP TABLE SUBJECT_OPENED;
DROP TABLE ENROLMENT;
DROP TABLE COURSE_OPENED;
DROP TABLE TEXTBOOK;
DROP TABLE SUBJECT;
DROP TABLE COURSE;
DROP TABLE CLASSROOM;
DROP TABLE POINTS;
DROP TABLE STUDENT;
DROP TABLE PROFESSOR;
DROP TABLE ADMIN;
*/




■ADMIN 

▷프로시저
-------------------------------------------------------------
INSERT ADMIN_ID
관리자아이디가 N글자 이하로 입력될 경우 예외처리 후 경고문.
INSERT ADMIN_PW
패스워드가 4~16자가 아닐 경우 예외처리 후 경고문

--PRC_ADMIN_INSERT(ADMIN_ID, ADMIN_PW)

CREATE OR REPLACE PROCEDURE PRC_ADMIN_INSERT
( V_ID			IN ADMIN.ADMIN_ID%TYPE
, V_PW			IN ADMIN.ADMIN_PW%TYPE 
)
IS
V_ADMIN_NUM         ADMIN.ADMIN_NUM%TYPE;

USER_DEFINE_ERROR 	EXCEPTION;
USER_DEFINE_ERROR2  EXCEPTION;
 
CURSOR CUR_ADMIN_ID
IS
SELECT ADMIN_ID
FROM ADMIN;

V_CHECK_ID      ADMIN.ADMIN_ID%TYPE;

BEGIN    
  OPEN CUR_ADMIN_ID;
    LOOP
    FETCH CUR_ADMIN_ID INTO V_CHECK_ID;
    EXIT WHEN CUR_ADMIN_ID%NOTFOUND;
    IF V_CHECK_ID = V_ID           
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    END LOOP;  
  CLOSE CUR_ADMIN_ID; 
  
  -- 어드민 번호 부여
  SELECT NVL(MAX(TO_NUMBER(SUBSTR(ADMIN_NUM ,3,4)))+1,1) INTO V_ADMIN_NUM 
  FROM ADMIN;
  
  IF V_ADMIN_NUM  = 1
     THEN  V_ADMIN_NUM  := '0001';
  ELSIF V_ADMIN_NUM  < 10
     THEN SELECT '000' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(ADMIN_NUM,6,1)))+1) INTO V_ADMIN_NUM 
          FROM ADMIN;
  ELSIF V_ADMIN_NUM  < 100
     THEN SELECT '00' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(ADMIN_NUM,5,2)))+1) INTO V_ADMIN_NUM 
          FROM ADMIN;
  ELSIF V_ADMIN_NUM < 1000
     THEN SELECT '0' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(ADMIN_NUM,4,3)))+1) INTO V_ADMIN_NUM 
          FROM ADMIN;
  ELSE
     SELECT TO_CHAR(MAX(TO_NUMBER(SUBSTR(ADMIN_NUM,5,4)))+1) INTO V_ADMIN_NUM 
     FROM ADMIN;
  END IF;
  
  -- 아이디 길이 체크
    IF LENGTH(V_ID) < 4 OR LENGTH(V_ID) > 16
		THEN RAISE USER_DEFINE_ERROR;
	END IF;
        
	INSERT INTO ADMIN(ADMIN_NUM, ADMIN_ID, ADMIN_PW)
	VALUES('AD'|| V_ADMIN_NUM, V_ID, V_PW);
	
     COMMIT;
    
    -- 예외 처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20016, '글자 수가 올바르지 않습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20017, '중복 불가한 데이터입니다.');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK; 
END;
--==>> Procedure PRC_ADMIN_INSERT이(가) 컴파일되었습니다.
---------------------------------------------------------------------

아이디, 패스워드가 일치할 경우에만 수정 가능

--PRC_ADMIN_UPDATE_PW(V_ID, V_PWOLD, V_PWNEW)

CREATE OR REPLACE PROCEDURE PRC_ADMIN_UPDATE
( V_ADMIN_NUM   IN ADMIN.ADMIN_NUM%TYPE
, V_ID			IN ADMIN.ADMIN_ID%TYPE
, V_PWOLD       IN ADMIN.ADMIN_PW%TYPE     -- 현재 비밀번호
, V_PWNEW	    IN ADMIN.ADMIN_PW%TYPE     -- 변경할 비밀번호
)
IS
 V_PW                   ADMIN.ADMIN_PW%TYPE; 
 USER_DEFINE_ERROR 	    EXCEPTION;
 USER_DEFINE_ERROR2     EXCEPTION;
BEGIN
    -- V_PW에 현재 패스워드 담기
    SELECT ADMIN_PW     INTO V_PW
    FROM ADMIN
    WHERE ADMIN_ID = V_ID AND ADMIN_NUM = V_ADMIN_NUM;
     
    IF LENGTH(V_PW) < 4 OR LENGTH(V_PW) > 16
		THEN RAISE USER_DEFINE_ERROR;
    ELSIF V_PWOLD = V_PW 
        THEN UPDATE ADMIN
                SET ADMIN_PW = V_PWNEW
              WHERE ADMIN_ID = V_ID AND ADMIN_NUM = V_ADMIN_NUM;
    ELSE RAISE USER_DEFINE_ERROR2;
    END IF;
    COMMIT;
    
    -- 예외 처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20016, '글자 수가 올바르지 않습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20010, '잘못된 비밀번호를 입력했습니다.');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK; 
END;
--==>> Procedure PRC_ADMIN_UPDATE이(가) 컴파일되었습니다.



--삭제 프로시저
CREATE OR REPLACE PROCEDURE PRC_ADMIN_DELETE
( V_ADMIN_NUM   IN ADMIN.ADMIN_NUM%TYPE
, V_ID			IN ADMIN.ADMIN_ID%TYPE
, V_PW			IN ADMIN.ADMIN_PW%TYPE 
)
IS  
V_ID_CHECK      ADMIN.ADMIN_ID%TYPE;
V_PW_CHECK      ADMIN.ADMIN_PW%TYPE;
USER_DEFINE_ERROR EXCEPTION;

BEGIN
     SELECT ADMIN_ID, ADMIN_PW INTO V_ID_CHECK, V_PW_CHECK
     FROM ADMIN
     WHERE V_ADMIN_NUM = ADMIN_NUM;
     
     IF V_ID = V_ID_CHECK AND V_PW = V_PW_CHECK
     THEN   DELETE 
            FROM ADMIN
            WHERE V_ADMIN_NUM  = ADMIN_NUM;
     ELSE RAISE USER_DEFINE_ERROR;
     END IF;
     COMMIT;
     
      EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;     
END;
------------------------------------------------------------------------------------


■COURSE 

-- INSERT 프로시저 PRC_COURSE_INSERTPRC_COURSE_INSERT(V_COUR_NAME)
CREATE OR REPLACE PROCEDURE PRC_COURSE_INSERT
( V_COUR_NAME    IN COURSE.COUR_NAME%TYPE
)
IS
  V_COUR_NUM      COURSE.COUR_NUM%TYPE;
  USER_DEFINE_ERROR     EXCEPTION;
  
BEGIN

  -- 예외
  IF LENGTH(V_COUR_NAME) < 4 OR LENGTH(V_COUR_NAME) > 16
		THEN RAISE USER_DEFINE_ERROR;
  END IF;
  
  SELECT NVL(MAX(TO_NUMBER(SUBSTR(COUR_NUM,2,4)))+1,1) INTO V_COUR_NUM
  FROM COURSE;
  
  IF V_COUR_NUM = 1
     THEN  V_COUR_NUM := '0001';
  ELSIF V_COUR_NUM < 10
     THEN SELECT '000' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(COUR_NUM,5,1)))+1) INTO V_COUR_NUM
          FROM COURSE;
  ELSIF V_COUR_NUM < 100
     THEN SELECT '00' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(COUR_NUM,4,2)))+1) INTO V_COUR_NUM
          FROM COURSE;
  ELSIF V_COUR_NUM < 1000
     THEN SELECT '0' || TO_CHAR(MAX(TO_NUMBER(SUBSTR(COUR_NUM,3,3)))+1) INTO V_COUR_NUM
          FROM COURSE;
  ELSE
     SELECT TO_CHAR(MAX(TO_NUMBER(SUBSTR(COUR_NUM,2,4)))+1) INTO V_COUR_NUM
     FROM COURSE;
  END IF;
    
  -- 쿼리문 구성 
  INSERT INTO COURSE(COUR_NUM, COUR_NAME)
  VALUES ('C' || V_COUR_NUM, V_COUR_NAME);
  
  COMMIT;
  EXCEPTION
    WHEN USER_DEFINE_ERROR 
    THEN RAISE_APPLICATION_ERROR(-20016, '글자 수가 올바르지 않습니다');
    ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
  -- 커밋
  -- COMMIT;
END;


-- UPDATE 프로시저
-- 과정번호가 일치할 경우에 변경 가능하도록
-- PRC_COURSE_UPDATE
CREATE OR REPLACE PROCEDURE PRC_COURSE_UPDATE
( V_COUR_NUM   IN COURSE.COUR_NUM%TYPE
, V_COUR_NAME  IN COURSE.COUR_NAME%TYPE
)
IS
  V_CHECK_NUM            COURSE.COUR_NUM%TYPE;
  USER_DEFINE_ERROR      EXCEPTION;
  USER_DEFINE_ERROR2     EXCEPTION;
BEGIN
-- 쿼리
    SELECT COUR_NUM INTO V_CHECK_NUM
    FROM COURSE
    WHERE V_COUR_NUM = COUR_NUM;
    
    IF LENGTH(V_COUR_NAME) < 4 OR LENGTH(V_COUR_NAME) > 16
         THEN RAISE USER_DEFINE_ERROR;
    ELSIF V_COUR_NUM = V_CHECK_NUM 
         THEN UPDATE COURSE
                 SET COUR_NAME = V_COUR_NAME
               WHERE COUR_NUM = V_COUR_NUM;
    ELSE RAISE USER_DEFINE_ERROR2;
    END IF;
  -- 커밋
  COMMIT;
  
   EXCEPTION
    WHEN USER_DEFINE_ERROR THEN RAISE_APPLICATION_ERROR(-20016, '글자 수가 올바르지 않습니다');
    ROLLBACK;
    WHEN USER_DEFINE_ERROR2 THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
    ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;


-- ◇ 삭제 트리거(과정이 이미 참조되고 있으면 = 과정개설이 이미 되었으면 삭제 불가)
CREATE OR REPLACE TRIGGER TRG_COURSE_DELETE
        BEFORE
        DELETE ON COURSE
        FOR EACH ROW
DECLARE
    V_RESULT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_RESULT
    FROM COURSE_OPENED
    WHERE COUR_NUM = :OLD.COUR_NUM;
        -- 만약 삭제하려는 과정 정보가 테이블에서 참조되고 있으면
    IF V_RESULT > 0 THEN
        RAISE_APPLICATION_ERROR(-20011, '삭제하려는 해당 객체는 참조되고 있습니다.');
    END IF;
END;


-- 삭제 프로시저 --> 개강 시작했으면 삭제 불가
CREATE OR REPLACE PROCEDURE PRC_COURSE_DELETE
( 
    V_COUR_NUM   IN COURSE.COUR_NUM%TYPE
)
IS  
    V_RESULT            NUMBER;
    V_CO_START          COURSE_OPENED.CO_START%TYPE;
    USER_DEFINE_ERROR   EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;
    USER_DEFINE_ERROR3  EXCEPTION;
BEGIN
    -- 과정 개강 날짜 가져오기
    SELECT MAX(CO_START)     INTO V_CO_START
    FROM COURSE_OPENED
    WHERE COUR_NUM = V_COUR_NUM;
    
    -- COUR_NUM 같은 데이터 존재하는지 여부 확인
    -- 오늘 날짜가 개강 이후라면 삭제 불가
    SELECT COUNT(*) INTO V_RESULT
    FROM COURSE
    WHERE COUR_NUM = V_COUR_NUM;
    
    IF V_RESULT = 0
        THEN RAISE USER_DEFINE_ERROR3;
    ELSIF V_RESULT > 0
        THEN  DELETE
                FROM COURSE
               WHERE COUR_NUM = V_COUR_NUM;
    ELSIF SYSDATE >= V_CO_START  
        THEN RAISE USER_DEFINE_ERROR2;
    ELSE RAISE USER_DEFINE_ERROR3;
    END IF;
    
    -- 커밋
    COMMIT;
    
    EXCEPTION
    WHEN NO_DATA_FOUND
         THEN RAISE_APPLICATION_ERROR(-20006, '객체가 존재하지않습니다.');
         ROLLBACK;
    WHEN USER_DEFINE_ERROR2
         THEN RAISE_APPLICATION_ERROR(-20055, '이미 해당 과정이 개강하여 과정변경이 불가합니다.');
         ROLLBACK;
    WHEN USER_DEFINE_ERROR3
         THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
         ROLLBACK;
END;




■SUBJECT_OPENED


▷ 개설과목 번호 부여 시퀀스

CREATE SEQUENCE SEQ_SUBJECT_OPENED
    START WITH 1001
    INCREMENT BY 1
    MAXVALUE 9999
    MINVALUE 1001 
    CACHE 20
    NOORDER 
    NOCYCLE;
    
▷프로시저

-- 입력프로시저(개설날짜, 과목번호, 과정번호, 교수번호, 시작날짜, 종료날짜, 배점번호, 책 번호, 시험내용, 시험날짜)

CREATE OR REPLACE PROCEDURE PRC_SUBJECT_OPENED_INSERT
(
  V_SO_DATE     IN SUBJECT_OPENED.SO_DATE%TYPE 
, V_SUBJ_NUM    IN SUBJECT_OPENED.SUBJ_NUM%TYPE
, V_CO_NUM      IN SUBJECT_OPENED.CO_NUM%TYPE
, V_PROF_NUM    IN SUBJECT_OPENED.PROF_NUM%TYPE        
, V_SO_START    IN SUBJECT_OPENED.SO_START%TYPE 
, V_SO_FINISH   IN SUBJECT_OPENED.SO_FINISH%TYPE
, V_PNT_NUM     IN SUBJECT_OPENED.PNT_NUM%TYPE
, V_BOOK_NUM    IN SUBJECT_OPENED.BOOK_NUM%TYPE 
, V_SO_EXAM     IN SUBJECT_OPENED.SO_EXAM%TYPE     
, V_EXAM_DATE   IN SUBJECT_OPENED.EXAM_DATE%TYPE
)
IS
  V_SO_NUM       SUBJECT_OPENED.SO_NUM%TYPE;
  V_CHECK_START  SUBJECT_OPENED.SO_START%TYPE; 
  V_CHECK_FINISH SUBJECT_OPENED.SO_FINISH%TYPE;
  USER_DEFINE_ERROR    EXCEPTION;
  
  CURSOR CUR_SO_DATE
  IS
  SELECT SO_START, SO_FINISH
  FROM SUBJECT_OPENED
  WHERE CO_NUM = V_CO_NUM;
  

BEGIN
  OPEN CUR_SO_DATE;
    LOOP
    FETCH CUR_SO_DATE INTO V_CHECK_START, V_CHECK_FINISH;
    EXIT WHEN CUR_SO_DATE%NOTFOUND;
    IF V_CHECK_START <= V_SO_FINISH AND V_SO_FINISH <= V_CHECK_FINISH              
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    END LOOP;
  CLOSE CUR_SO_DATE; 

  -- 과목시작일자<오늘(등록일자) 예외처리
  IF V_SO_START < SYSDATE
    THEN RAISE USER_DEFINE_ERROR;
  END IF;
  
  -- 과목종료일자>과목시작일자 예외처리
  IF V_SO_START > V_SO_FINISH 
    THEN RAISE USER_DEFINE_ERROR;
  END IF;
  
  -- 시험일자<과목시작일자 OR 시험일자>과목종료일자 예외처리
  IF V_EXAM_DATE < V_SO_START OR V_EXAM_DATE > V_SO_FINISH
     THEN RAISE USER_DEFINE_ERROR;
  END IF;
  

  -- 현재 과정에서 개설된 과목과 겹치는 것이 없는지.. 확인
  
   -- 과목번호 및 기타 데이터 입력 쿼리
   INSERT INTO SUBJECT_OPENED(SO_NUM, SO_DATE, SUBJ_NUM, CO_NUM, PROF_NUM, SO_START, SO_FINISH, PNT_NUM, BOOK_NUM, SO_EXAM, EXAM_DATE)
   VALUES('SO'||TO_CHAR(SEQ_SUBJECT_OPENED.NEXTVAL), V_SO_DATE, V_SUBJ_NUM, V_CO_NUM, V_PROF_NUM, V_SO_START, V_SO_FINISH, V_PNT_NUM, V_BOOK_NUM, V_SO_EXAM, V_EXAM_DATE); 

   COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR THEN RAISE_APPLICATION_ERROR(-20019, '올바른 기간이 아닙니다');
        ROLLBACK;
    WHEN OTHERS THEN
         -- raise_application_error(-20001,'에러발생! 에러코드 => '||SQLCODE|| ' 에러메시지 => ' ||SQLERRM);
    ROLLBACK; 
END;

--------------------------------------------------------------------------------------------

-- 1. 과목번호 변경 PROC_SO_UPDATE(과목개설번호, 새로운 과목번호)
-- SO_START 이후에는 변경 불가

CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_SBJN
( V_SO_NUM       IN SUBJECT_OPENED.SO_NUM%TYPE
, V_SUBJ_NUM     IN SUBJECT_OPENED.SUBJ_NUM%TYPE
)
IS
  CURSOR CUR_SO_SUBJN
  IS
  SELECT SUBJ_NUM
  FROM SUBJECT;  
  
  V_RESULT            NUMBER;
  V_SO_START          SUBJECT_OPENED.SO_START%TYPE;
  USER_DEFINE_ERROR   EXCEPTION;
  USER_DEFINE_ERROR2  EXCEPTION;
  
BEGIN 

-- 개강 날짜 받아오기
  SELECT SO_START   INTO  V_SO_START 
  FROM SUBJECT_OPENED
  WHERE V_SO_NUM = SO_NUM;
  
-- 입력된 과목번호가 과목 테이블에 존재하는지 여부 확인
    SELECT COUNT(*) INTO V_RESULT
    FROM SUBJECT
    WHERE SUBJ_NUM = V_SUBJ_NUM;
    
    IF V_RESULT < 1
        THEN RAISE USER_DEFINE_ERROR2; 
    ELSIF SYSDATE <= V_SO_START  -- 개강 이전이라면 해당 값을 변경
        THEN    UPDATE SUBJECT_OPENED
                  SET SUBJ_NUM = V_SUBJ_NUM
                WHERE SO_NUM = V_SO_NUM;
    ELSE RAISE USER_DEFINE_ERROR;
    END IF;

  COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20012, '개강한 과정은 수강신청/변경이 불가합니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR2 
        THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
        ROLLBACK;
    WHEN OTHERS THEN 
    -- raise_application_error(-20001,'에러발생! 에러코드 => '||SQLCODE|| ' 에러메시지 => ' ||SQLERRM);
    ROLLBACK;
END;



-- 2. 과정번호 변경하기 (개설과목번호, 새로운 과정번호)
CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_CON
( V_SO_NUM     IN SUBJECT_OPENED.SO_NUM%TYPE
, V_CO_NUM     IN SUBJECT_OPENED.CO_NUM%TYPE
)
IS
  V_RESULT            NUMBER;
  V_SO_START          SUBJECT_OPENED.SO_START%TYPE;
  USER_DEFINE_ERROR   EXCEPTION;
  USER_DEFINE_ERROR2  EXCEPTION;
BEGIN 
    -- 개강 날짜 받아오기
    SELECT SO_START   INTO  V_SO_START 
    FROM SUBJECT_OPENED
    WHERE V_SO_NUM = SO_NUM;
    
    -- 입력된 과목번호가 과목 테이블에 존재하는지 여부 확인
    SELECT COUNT(*) INTO V_RESULT
    FROM COURSE_OPENED
    WHERE CO_NUM = V_CO_NUM;
    
    IF V_RESULT < 1
        THEN RAISE USER_DEFINE_ERROR2; 
    ELSIF SYSDATE <= V_SO_START  -- 개강 이전이라면 해당 값을 변경
        THEN    UPDATE SUBJECT_OPENED
                  SET CO_NUM = V_CO_NUM
                WHERE SO_NUM = V_SO_NUM;
    ELSE RAISE USER_DEFINE_ERROR;
    END IF;

  COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20012, '개강한 과정은 수강신청/변경이 불가합니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR2 
        THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
        ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;



-- 3. 교수번호 변경 PROC_SO_UPDATE(개설과목, 바꿀 교수번호)
-- SO_START 이후에는 변경 불가

CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_PFN
( V_SO_NUM       IN SUBJECT_OPENED.SO_NUM%TYPE
, V_PROF_NUM     IN SUBJECT_OPENED.SUBJ_NUM%TYPE
)
IS
  V_RESULT            NUMBER;
  V_SO_START          SUBJECT_OPENED.SO_START%TYPE;
  USER_DEFINE_ERROR   EXCEPTION;
  USER_DEFINE_ERROR2  EXCEPTION;
BEGIN 
  -- 개강 날짜 받아오기
    SELECT SO_START   INTO  V_SO_START 
    FROM SUBJECT_OPENED
    WHERE V_SO_NUM = SO_NUM;
    
    -- 입력된 과목번호가 과목 테이블에 존재하는지 여부 확인
    SELECT COUNT(*) INTO V_RESULT
    FROM  PROFESSOR
    WHERE PROF_NUM = V_PROF_NUM;
    
    IF V_RESULT < 1
        THEN RAISE USER_DEFINE_ERROR2; 
    ELSIF SYSDATE <= V_SO_START  -- 개강 이전이라면 해당 값을 변경
        THEN    UPDATE SUBJECT_OPENED
                  SET PROF_NUM = V_PROF_NUM
                WHERE SO_NUM = V_SO_NUM;
    ELSE RAISE USER_DEFINE_ERROR;
    END IF;


-- 해당 교수가 이미 강의를 진행 중이라면 변경 불가
-- 지금 이 과목 날짜 가져옴
-- 사용자가 입력한 교수번호


  COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20012, '개강한 과정은 수강신청/변경이 불가합니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR2 
        THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
        ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;


-- 4.시작/종료 시험 날짜 변경(과목개설 번호, 시작날짜, 종료날짜, 시험날짜)
-- 이미 개강한 과목과

CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_DATE
( V_SO_NUM       IN SUBJECT_OPENED.SO_NUM%TYPE
, V_SO_START     IN SUBJECT_OPENED.SO_START%TYPE
, V_SO_FINISH    IN SUBJECT_OPENED.SO_FINISH%TYPE
, V_EXAM_DATE    IN SUBJECT_OPENED.EXAM_DATE%TYPE
)
IS
  V_RESULT               NUMBER;
  V_CHECK_START          SUBJECT_OPENED.SO_START%TYPE;
  USER_DEFINE_ERROR      EXCEPTION;
  USER_DEFINE_ERROR2     EXCEPTION;
  USER_DEFINE_ERROR3     EXCEPTION;
  
  CURSOR CUR_SO_DATE                    -- 과목개설에 있는 다른 과목들의 기간과 겹치지 않나 확인하는 커서
  IS
  SELECT SO_START, SO_FINISH
  FROM SUBJECT_OPENED
  
BEGIN 

  -- 개강 이후라면 변경불가, 입력한 과목번호가 일치하면 바꾸고 싶은 과목번호와 일치하면 해당 값을 변경  
  SELECT COUNT(*) INTO V_RESULT
  FROM SUBJECT_OPENED
  WHERE SO_NUM = V_SO_NUM;
    
  OPEN CUR_SO_DATE;
    LOOP
    FETCH CUR_SO_DATE INTO V_CHECK_START, V_CHECK_FINISH;
    EXIT WHEN CUR_SO_DATE%NOTFOUND;
    IF V_CHECK_START <= V_SO_FINISH AND V_SO_FINISH <= V_CHECK_FINISH              
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    END LOOP;
  CLOSE CUR_SO_DATE; 

  -- 수정하고 싶은 날짜의 개강 날짜 받아오기
  SELECT SO_START   INTO  V_CHECK_START 
  FROM SUBJECT_OPENED
  WHERE V_SO_NUM = SO_NUM;
  
  IF V_RESULT < 1
    THEN RAISE USER_DEFINE_ERROR3; 
  ELSIF SYSDATE > V_CHECK_START 
    THEN RAISE USER_DEFINE_ERROR;
  ELSIF V_SO_FINISH < V_SO_START OR SYSDATE > V_SO_START OR V_EXAM_DATE < V_SO_START OR V_EXAM_DATE > V_SO_FINISH
    THEN RAISE USER_DEFINE_ERROR2;
  ELSE UPDATE SUBJECT_OPENED
         SET SO_START = V_SO_START, SO_FINISH = V_SO_FINISH, EXAM_DATE = V_EXAM_DATE
         WHERE V_SO_NUM = SO_NUM;
  END IF;
  
  COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20012, '개강한 과정은 수강신청/변경이 불가합니다.');
        ROLLBACK;
     WHEN USER_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20019, '올바른 기간이 아닙니다');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR3
        THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
        ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;


  
-- 개설과목 테이블에 이미 같은 날짜로 개강한 과목이 있다면 변경 불가


-- 5. 배점 번호 변경(개설과목 번호, 새로운 배점번호)
CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_POINT
( V_SO_NUM       IN SUBJECT_OPENED.SO_NUM%TYPE
, V_PNT_NUM      IN SUBJECT_OPENED.PNT_NUM%TYPE
)
IS
  V_RESULT            NUMBER;
  V_SO_START          SUBJECT_OPENED.SO_START%TYPE;
  USER_DEFINE_ERROR   EXCEPTION;
  USER_DEFINE_ERROR2  EXCEPTION;
BEGIN 
  -- 개강 날짜 받아오기
    SELECT SO_START   INTO  V_SO_START 
    FROM SUBJECT_OPENED
    WHERE V_SO_NUM = SO_NUM;
    
    -- 입력된 과목번호가 과목 테이블에 존재하는지 여부 확인
    SELECT COUNT(*) INTO V_RESULT
    FROM  POINTS
    WHERE PNT_NUM = V_PNT_NUM;
    
    IF V_RESULT < 1
        THEN RAISE USER_DEFINE_ERROR2; 
    ELSIF SYSDATE <= V_SO_START  -- 개강 이전이라면 해당 값을 변경
        THEN    UPDATE SUBJECT_OPENED
                  SET PNT_NUM = V_PNT_NUM
                WHERE SO_NUM = V_SO_NUM;
    ELSE RAISE USER_DEFINE_ERROR;
    END IF;

  COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20012, '개강한 과정은 수강신청/변경이 불가합니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR2 
        THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
        ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;



-- 6. 책 변경(개설 과목 번호, 바꿀 책 번호)
CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_BOOK
( V_SO_NUM       IN SUBJECT_OPENED.SO_NUM%TYPE
, V_BOOK_NUM      IN SUBJECT_OPENED.BOOK_NUM%TYPE
)
IS
  V_CHECK_FINISH          SUBJECT_OPENED.SO_FINISH%TYPE;
  V_CHECK_NUM             SUBJECT_OPENED.SO_NUM%TYPE;
  USER_DEFINE_ERROR       EXCEPTION;
  USER_DEFINE_ERROR2      EXCEPTION;
BEGIN 

  -- 체크용 과목개설 번호
  SELECT SO_NUM     INTO V_CHECK_NUM
  FROM SUBJECT_OPENED
  WHERE SO_NUM = V_SO_NUM;
  
  -- 종강 날짜 받아오기
  SELECT SO_FINISH   INTO  V_CHECK_FINISH
  FROM SUBJECT_OPENED
  WHERE V_SO_NUM = SO_NUM;
  
  -- 종강 이후라면 변경불가, 종강 이후고 입력한 과목번호가 일치하면 바꾸고 싶은 과목번호와 일치하면 해당 값을 변경
  IF SYSDATE > V_CHECK_FINISH
    THEN RAISE USER_DEFINE_ERROR;
  ELSIF V_SO_NUM = V_CHECK_NUM
    THEN UPDATE SUBJECT_OPENED
         SET BOOK_NUM = V_BOOK_NUM
         WHERE V_SO_NUM = SO_NUM;
  ELSE RAISE USER_DEFINE_ERROR2;
  END IF;
  
  COMMIT;
   EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20013, '종강한 과정은 수강신청/변경이 불가합니다.');
        ROLLBACK;
    WHEN USER_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20006, '객체가 존재하지않습니다.');
        ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;



-- 7. 시험 내용 변경
CREATE OR REPLACE PROCEDURE PRC_SO_UPDATE_EXAM
( V_SO_NUM       IN SUBJECT_OPENED.SO_NUM%TYPE
, V_SO_EXAM      IN SUBJECT_OPENED.SO_EXAM%TYPE
)
IS
  V_CHECK_DATE             SUBJECT_OPENED.EXAM_DATE%TYPE;
  USER_DEFINE_ERROR   EXCEPTION;
BEGIN 

  -- 체크용 날짜
  SELECT EXAM_DATE     INTO V_CHECK_DATE
  FROM SUBJECT_OPENED
  WHERE SO_NUM = V_SO_NUM;
  
  
  -- 시험 날짜 지난 이후에는 변경 불가, 입력한 과목번호가 일치하면 바꾸고 싶은 과목번호와 일치하면 해당 값을 변경
  IF V_CHECK_DATE > SYSDATE
    THEN UPDATE SUBJECT_OPENED
            SET SO_EXAM = V_SO_EXAM 
          WHERE V_SO_NUM = SO_NUM;
   ELSE RAISE USER_DEFINE_ERROR;
  END IF;
  
  COMMIT;
  
  EXCEPTION
    WHEN USER_DEFINE_ERROR 
        THEN RAISE_APPLICATION_ERROR(-20020, '시험 기간이 지난 후에는 변경이 불가합니다.');
        ROLLBACK;
    WHEN OTHERS THEN ROLLBACK;
END;





▷ 삭제 트리거(과목개설이 이미 참조되고 있으면 = 개강이면 삭제 불가)
CREATE OR REPLACE TRIGGER TRG_SO_DELETE
        BEFORE
        DELETE ON SUBJECT_OPENED
        FOR EACH ROW
DECLARE
    V_RESULT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_RESULT
    FROM GRADE
    WHERE SO_NUM = :OLD.SO_NUM;
        -- 만약 삭제하려는 과정 정보가 테이블에서 참조되고 있으면
    IF V_RESULT > 0 THEN
        RAISE_APPLICATION_ERROR(-20011, '삭제하려는 해당 객체는 참조되고 있습니다.');
    END IF;
END;


CREATE OR REPLACE PROCEDURE PRC_SO_DELETE
( 
    V_SO_NUM   IN SUBJECT_OPENED.SO_NUM%TYPE
)
IS  
    V_RESULT            NUMBER;
    V_SO_START          SUBJECT_OPENED.SO_START%TYPE;
    USER_DEFINE_ERROR   EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;
    USER_DEFINE_ERROR3  EXCEPTION;
BEGIN
    -- 개강 날짜 가져오기
    SELECT SO_START     INTO V_SO_START
    FROM SUBJECT_OPENED
    WHERE SO_NUM = V_SO_NUM;
    
    -- SO_NUM 같은 데이터 존재하는지 여부 확인
    -- 오늘 날짜가 개강 이후라면 삭제 불가
    SELECT COUNT(*) INTO V_RESULT
    FROM SUBJECT_OPENED
    WHERE SO_NUM = V_SO_NUM;
    
    IF V_RESULT = 0
        THEN RAISE USER_DEFINE_ERROR3;
    ELSIF V_RESULT > 0
        THEN  DELETE
                FROM SUBJECT_OPENED
               WHERE SO_NUM = V_SO_NUM;
    ELSIF SYSDATE >= V_SO_START  
        THEN RAISE USER_DEFINE_ERROR2;
    ELSE RAISE USER_DEFINE_ERROR3;
    END IF;
    
    -- 커밋
    COMMIT;
    
    EXCEPTION
    WHEN NO_DATA_FOUND
         THEN RAISE_APPLICATION_ERROR(-20006, '객체가 존재하지않습니다.');
         ROLLBACK;
    WHEN USER_DEFINE_ERROR2
         THEN RAISE_APPLICATION_ERROR(-20055, '이미 해당 과정이 개강하여 과정변경이 불가합니다.');
         ROLLBACK;
    WHEN USER_DEFINE_ERROR3
         THEN RAISE_APPLICATION_ERROR(-20018, '입력 정보가 데이터와 일치하지 않습니다.');
         ROLLBACK;
END;




